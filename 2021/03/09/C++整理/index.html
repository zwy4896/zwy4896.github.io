<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Bluzy的小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C++文件编译与执行的四个阶段 预处理：根据文件中的    预处理指令修改源文件内容 编译：编译成汇编代码 汇编：把汇编语言翻译成目标机器指令 链接：链接目标代码生成可执行程序  堆和栈的区别堆：  人为分配的内存块，需要手动delete，程序结束后由操作系统自动回收。 分配和释放需要使用new&#x2F;delete，造成内存空间的不连续，会有大量碎片 生长空间越向上，地址越大  栈：  存放函数的参数、">
<meta property="og:type" content="article">
<meta property="og:title" content="Bluzy的小站">
<meta property="og:url" content="http://example.com/2021/03/09/C++%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Bluzy的小站">
<meta property="og:description" content="C++文件编译与执行的四个阶段 预处理：根据文件中的    预处理指令修改源文件内容 编译：编译成汇编代码 汇编：把汇编语言翻译成目标机器指令 链接：链接目标代码生成可执行程序  堆和栈的区别堆：  人为分配的内存块，需要手动delete，程序结束后由操作系统自动回收。 分配和释放需要使用new&#x2F;delete，造成内存空间的不连续，会有大量碎片 生长空间越向上，地址越大  栈：  存放函数的参数、">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-09T06:00:44.614Z">
<meta property="article:modified_time" content="2021-03-09T07:42:24.960Z">
<meta property="article:author" content="Bluzy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Bluzy的小站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bluzy的小站</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-C++整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/09/C++%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-03-09T06:00:44.614Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-文件编译与执行的四个阶段"><a href="#C-文件编译与执行的四个阶段" class="headerlink" title="C++文件编译与执行的四个阶段"></a>C++文件编译与执行的四个阶段</h1><ol>
<li>预处理：根据文件中的    预处理指令修改源文件内容</li>
<li>编译：编译成汇编代码</li>
<li>汇编：把汇编语言翻译成目标机器指令</li>
<li>链接：链接目标代码生成可执行程序</li>
</ol>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>堆：</p>
<ul>
<li>人为分配的内存块，需要手动delete，程序结束后由操作系统自动回收。</li>
<li>分配和释放需要使用new/delete，造成内存空间的不连续，会有大量碎片</li>
<li>生长空间越向上，地址越大</li>
</ul>
<p>栈：</p>
<ul>
<li>存放函数的参数、局部变量，由编译器自动分配释放。</li>
<li>生长空间越向下，地址越小</li>
</ul>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p>如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。</p>
<h1 id="哪些成员函数不能被继承"><a href="#哪些成员函数不能被继承" class="headerlink" title="哪些成员函数不能被继承"></a>哪些成员函数不能被继承</h1><p>构造函数、析构函数、赋值运算符重载函数</p>
<h1 id="基类的析构函数为什么要用virtual虚析构函数"><a href="#基类的析构函数为什么要用virtual虚析构函数" class="headerlink" title="基类的析构函数为什么要用virtual虚析构函数"></a>基类的析构函数为什么要用virtual虚析构函数</h1><p>防止内存泄漏，如果基类的析构函数不是虚函数，在delete基类，调用析构函数时，只会看指针的数据类型，而不会去看赋值对象，这样就会造成内存泄漏。</p>
<h1 id="哪些函数不能声明成虚函数"><a href="#哪些函数不能声明成虚函数" class="headerlink" title="哪些函数不能声明成虚函数"></a>哪些函数不能声明成虚函数</h1><p>非成员函数、构造函数、静态成员函数、内联成员函数、友元函数</p>
<ol>
<li>非成员函数</li>
</ol>
<p>非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？</p>
<ol start="2">
<li>构造函数</li>
</ol>
<p>要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了。</p>
<ol start="3">
<li>静态成员函数</li>
</ol>
<p>静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上才可以的，两者一个是与实例相关，一个是与类相关。</p>
<ol start="4">
<li>内联成员函数</li>
</ol>
<p>内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数。</p>
<ol start="5">
<li>友元函数</li>
</ol>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。</p>
<h1 id="内存分配方式以及它们的区别"><a href="#内存分配方式以及它们的区别" class="headerlink" title="内存分配方式以及它们的区别"></a>内存分配方式以及它们的区别</h1><ol>
<li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在</li>
<li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。</li>
</ol>
<h1 id="进程间通信方式和线程间通信方式"><a href="#进程间通信方式和线程间通信方式" class="headerlink" title="进程间通信方式和线程间通信方式"></a>进程间通信方式和线程间通信方式</h1><ol>
<li>进程间通信方式</li>
</ol>
<ul>
<li>管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<ol start="2">
<li>线程间通信方式</li>
</ol>
<ul>
<li>全局变量</li>
<li>Message消息机制</li>
<li>CEvent对象</li>
</ul>
<h1 id="STL库的容器和算法"><a href="#STL库的容器和算法" class="headerlink" title="STL库的容器和算法"></a>STL库的容器和算法</h1><p>STL包括两部分：容器和算法</p>
<p>容器即存放数据的地方，比如array，vector。分为序列式容器和关联式容器</p>
<ul>
<li>序列式容器：其中的元素不一定有序，但是都可以被排序比如vector,list,queue,stack，heap, priority-queue, slist</li>
<li>关联式容器：内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set</li>
</ul>
<p>算法有排序，复制等，以及各个容器特定的算法。</p>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><p>数组要么在<strong>静态存储区</strong>被创建（如全局数组），要么在<strong>栈</strong>上被创建。指针可以随时指向<strong>任意类型</strong>的内存块。</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ol>
<li>指针是一个新的变量，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量； 引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身进行操作</li>
<li>引用只能在初始化时被赋值，指针的值可在任意时候被改变</li>
<li>引用不能为NULL，指针可以为NULL</li>
<li>引用必须初始化，指针不必</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/C++%E6%95%B4%E7%90%86/" data-id="ckm20hm240000ez6fhvk8eul2" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/09/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 10px;">教程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/09/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">hexo搭建个人博客</a>
          </li>
        
          <li>
            <a href="/2021/03/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/03/09/C++%E6%95%B4%E7%90%86/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Bluzy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>